# 웹에서 가속을 이끌어내는 방법

## 1. 웹 브라우저 현황

- 웹 페이지 경량화&요청 수 줄여도 HTML을 화면에 그리는 것은 웹 브라우저
- => 프런트엔드 최적화의 핵심
  > 브라우저가 페이지를 화면에 렌더링하는 방식 이해&최적화
- 데스크톱 브라우저 점유율
  - 크롬 > Firefox > Safari > Edge Legacy > IE > Other
- 모바일 브라우저 점유율
  - 크롬 > Safari > Sansung Internet > UC Browser > Opera > Android > Firefox > Ohter
- 국내 데스크톱 브라우저 점유율
  - 크롬 > IE > Other
- 국내 모바일 브라우저 점유율
  - 크롬 > Samsung Internet > Safari > Other
    > 점유율 높은 브라우저에 대한 이미지 별도 준비하는 것이 효율적
- 국내 점유율이 높은 IE와 크롬에서 지원하는 이미지 형식, 폰트 타입 다르므로 주의
- 각 브라우저의 웹 페이지 전송, 렌더링 방식에는 큰 차이 없음
  - HTML해석해 이에 맞도록 객체 생성, 화면 크기에 맞춰 그림

## 2. 웹 브라우저 동작 이해하기

- 브라우저에서 웹 사이트 요청하는 순서: 브라우저에서 웹 사이트 주소이용해 서버에서 웹 페이지 다운하기까지의 흐름
  - IP찾기(DNS Resolving): 도메인 서버와 통신해 접속하려는 호스트의 IP찾음
  - TCP연결생성: 해당 IP의 서버와 통신해 TCP연결(HTTPS의 경우 암호화 연결생성위한 협의 단계 추가)
  - 리소스 다운로드: 연결완료 후 브라우저가 서버에서 필요한 리소스 다운해 화면에 표현
    - 방문 페이지의 HTML을 서버에 요청해 다운
    - HTML 구문을 분석(parsing)하며 하위 리소스 차례로 다운(HTML 태그에 참조된 CSS, JS image, font,,)
- 브라우저 아키텍처: 브라우저는 크게 7개의 컴포넌트로 구성
  - 유저 인터페이스: 사용다가 브라우저 통해 상호작용 가능하게 함
  - 브라우저 엔진: 유저 인터페이스-렌더링엔진 사이에서 렌더링 상태 조회, 렌더링 작업 제어위한 인터페이스 제공
  - 렌더링 엔진: 실제 웹 콘텐츠를 브라우저창에 그림(HTML분석해 표현, CSS분석해 웹 페이지 꾸밈)
    > 실제로 HTML 처리해 화면에 렌더링 하는 컴포넌트
    - ex) Webkit(safari), Gecko(firefox), Blink(크롬), Trident(IE) 렌더링 엔진
  - 네트워킹: 네트워크 통해 HTTP요청&응답 받음(DNS조회, TCP연결)
  - UI 백엔드: 콤보박스, 드롭박스,,, 기본적인 UI 컴포넌트 제공
  - 자바스크립트 해석기: JS 분석&해석(V8, Spider Monkey)
  - 데이터 저장소: 데이터 지속성 유지(쿠키, localStorage, indexDB)
- 중요 렌더링 경로
  - 렌더링 엔진의 작업은 선후관계 명확해 단일 스레드의해 수행
    - HTML해석안되면 CSS,JS수행불가, 객체모델 미생성시 브라우저의 화면구성 불가,,
  - 브라우저의 중요 렌더링 경로(Critical Rendering Path)
    1. 브라우저는 처음으로 HTML 구문분석해 DOM 트리 생성
    2. CSS 구문분석해 CSSOM 트리 생성
    3. 두 트리모델 결합해 최종적으로 렌더트리 생성
    4. 브라우저가 렌더트리 기반으로 페이지구조 결정&화면에 표현
  - DOM 트리 생성
    - 브라우저가 가장 먼저 다운한HTML 구문 분석해 태그 하나하나 해석하여 DOM 객체모델로 변환
      - 마크업언어: HTML, XML, 사람 가독성 좋으나 컴퓨터가 이용하기 어려움
      - !DOM: 객체지향적 프로그래밍 언어들로 마크업 문서를 쉽게 프로그래밍 하기위해 표준으로 규정한 프로그램 인터페이스 / 객체 속성, 메소드, 이벤트 등을 정의
  - CSSOM 트리 생성
    - 브라우저가 HTML 구문분석하며 CSS 참조링크 만날 시 해당 CSS 리소스 다운후 구문 분석기가 CSS 분석
    - HTML구문분석과정이 CSS분석에 방해받지 않음: HTML과 다르게 엄격한 구문검사, 구문 분석방법 달라 사용하는 구문 분석기, 동작 스레드 다름
    - !CSSOM: CSS 처리위한 트리구조의 프로그래밍 인터페이스
  - 렌더 트리생성
    - DOM트리와 CSSOM트리 구문 분석완료 시 브라우저가 두 트리 병합
    - !렌더트리: DOM, CSSOM 기반으로 렌더링 위한 최종정보 가진 렌더 객체 생성해 상하관계 트리모양으로 구성
  - 레이아웃
    - 렌더 트리 노드들의 위치 정보 계산
      - 렌더 객체는 사각형 영역 표시 -> 브라우저 창 맨 왼쪽위~아래, 오른쪽으로 이동하며 각 사각형 영역의 너비, 높이 계산
      - 루트노드의 너비: 뷰 포트의 크기
      - 부모 노드의 너비따라 자식 노드 너비 계산, 재귀적
      - 자식 노드의 높이따라 부모 노드 높이 계산, 재귀적
  - 페인트
    - 렌더 트리 정보 바탕으로 브라우저 창에 표현
    - 렌더링위한 정보 모두 존재하므로 GPU이용해 그리면 됨
  - > JS의 경우 DOM, CSSOM 동적으로 변경 가능
    - 변경시 렌더트리 변경&레이아웃, 페인트 재수행
    - JS방해 없이 렌더링 최적화하는 방법 필요

## 3. 브라우저 렌더링 최적화하기

- DOM 최적화 하기
  - HTML의 경우 구문체크에 관대: 문법오류시에도 브라우저에 정상 출력
    - 내부 알고리즘에서 오류 수정: 오류 많을 수록 예외처리위해 메모리,CPU소모
  - 웹사이트 성능 향상
    - > HTML 구문오류 최소화, 간소화
    - > HTML 태그 중첩 최소화: 15단계 이하의 중첩 태그권장
    - > DOM Monster: DOM분석해 최적화 방안 찾는 도구
- JS와 CSS 배치하기
  - JS의 경우 생성된 DOM, CSSOM 변경가능
    - HTML 구문분석기가 HTML해석 중에 JS만나면 다운로드&수행까지 DOM 생성작업 중단 = JS의한 변경완료까지 대기
    - 만약 CSS구문분석, CSSOM생성 작업 중일 경우 완료까지 JS 중단~> 스타일시트 생성전에 이를 JS가 수정하려는 경우 오류발생 = CSS가 JS보다 높은 우선순위
    - > CSS, JS 모두 전체 렌더링 과정 지연 가능한 렌더링 방해 리소스
  - 웹 사이트 성능향상
    - > CSS를 최대한 소스 앞쪽에 배치: CSSOM 빠르게 생성
    - > JS를 최대한 HTML 아래에 배치: DOM, CSSOM생성 후 수행
  - (TOP: CSS, Bottom: JS) vs (TOP: JS, Bottom: CSS) 비교
    - 모든 리소스 다운해 페이지 로딩완료 시점: 2.4s로 비슷
    - 렌더링 시작시점: 0.9s vs 1.5s로 0.5초 차이
- JS 최적화하기
  - JS수행이 렌더링 스레드 작업 방해않도록 별도 스레드로 수행 & 렌더링 작업이 어느정도 끝난 후 스크립트 수행
  - JS제공하는 속성: 분석, 광고용 타사JS에 사용해 메인 페이지 렌더링에 영향않도록 구현
    - aysnc: 구문분석과 동시에 JS다운&수행
      - 지연 수행시 스크립트 간 선후관계 비고려
      - `<script src="async.js" async> </script>`
    - defer: 구문분석 중 별도 스레드로 JS다운&구문분석종료 후 수행
      - 스크립트 호출 순서에 따라 차례로 수행
      - `<script src="defer.js" defer> </script>`
  - 모든 JS가 비동기, 지연처리의 대상 불가
    - JS를 초기 렌더링에 필요한 그룹 / 그렇지 않은 그룹으로 분류해 후자에 async, defer속성 적용
  - 브라우저가 페이지로딩 명시적으로 끝낸 후 나머지 스크립트 수행
    - 브라우저의 페이지 로딩 완료시 onload이벤트 발생
    - onload 이후 스크립트 수행시켜 페이지 로딩시간 단축
- CSS 최적화하기
  - CSS: 렌더링순위 최상위&렌더링 방해하는 리소스(브라우저는 CSS구문분석되고 CSSOM생성까지 렌더링 멈춤)
  - CSS 적절히 분리해 필요한 페이지에 필요한 CSS파일만 포함
  - 첫화면의 CSS파일, 숨겨진 화면의 CSS파일 분리해 후자는 지연수행
    - 미디어 쿼리 이용
      - `<link rel="stylesheet" type="text/css" media="screen and (max-device-width: 480px)" href="style_base.css">`
    - 숨겨진 화면에 적용될 CSS에 onLoad이벤트 발생 후 적용되게 처리
- 이미지 로딩 최적화하기
  - 이미지 로딩 최적화는 다른 방법에 비해 효율적
  - 렌더링에 필요치 않은 이미지 다운 회피방법
    - 해당 이미지가 주요 이미지가 아니면 CSS background-image이용
    - JS를 이용한 지연 로딩 방식
      - 모든 이미지에 적용시 브라우저 프리로더가 이미지 다운 불가해 성능 저하
      - 첫화면에 등장않거나 숨겨진 이미지 다운시 이용
      - !프리로더: 브라우저 자원의 효율적 사용위해 렌더링 스레드와 별도 스레드로 진행, 다운로드 가능 리소스 동시에 다운
        - <`img src="URI">같은 HTHML 표준에 정의된 태그, 속성만 분석해 다운
        - 사용자 정의속성 활용하는 지연로딩방식에 적용불가
    - Progressive JPG 활용
      - 고품질 이미지를 분할 전송하는 방식
      - 브라우저 초기에 저품질 이미지가 보이나 점차 원래 품질 회복
      - 인터넷 속도 느린 구간에서 사용자가 이미지 빨리볼수있는 이점

## 4. 도메인 분할 기법 이용하기

- 도메인 분할 기법: 여러 도메인을 소유한 경우 웹 콘텐츠 병렬적으로 동시에 다운 가능하게 하는 방법
  - > HTTP/1.1 프로토콜 하에서 브라우저의 제약 회피하는 방식
  - HTTP/1.1 프로토콜: 동일 도메인에 순차적 다운로드 방식이용
  - 브라우저는 동일 호스트명의 동시 연결개수 제한함
    - 한 도메인당 6~13개의 TCP연결 생성해 여러 리소스 한번에 다운
    - 브라우저: 최대동시 연결 개수) IE 11.0: 13, 그 외 브라우저: 6
      - 도메인 분할로 2개의 도메인 이용시 6개의 동시 연결지원하는 브라우저의 경우 12개의 연결 가능
  - 추가 도메인 디자인 방법) www.feokorea.com 사이트 운영시
    - www.feokorea.com: 웹 사이트 메인 페이지 및 동적콘텐츠위한 도메인
    - img.feokorea.com: 이미지 호출위한 도메인
    - script.feokorea.com: JS,CSS같은 정적 콘텐츠위한 도메인
    - api.feokorea.com: API 서비스 사용위한 도메인
  - > 하나의 웹 페이지의 리소스 수에 따라 추가할 서브도메인 수 결정
    - 동시 다운 숫자증가시 CPU리소스 사용 증가, CPU리소스 한계시 다운로드 속도 감소
    - 각 도메인에 대한 DNS조회 및 TCP연결을 생성하고 유지하여 페이지 로딩 속도 감소
    - > 테스트 통해 적정 도메인 숫자 결정
  - 도메인 수 결정 시 수에 맞게 리소스 균등분할
    - 특정 도메인에서 대부분의 리소스 다운 시 다른 도메인은 TCP연결 위한 리소스만 낭비
  - 리소스 분류 방법
    - 성격따라 분류
      - JS,CSS,폰트 등 렌더링과 이미지 멀티미디어 리소스 종류 별로 구분, 도메인 별로 균등하게 분배, 관리 간편
    - 동적으로 분류
      - 배포시점에 동적을 도메인 명 결정, 보다 정확한 분배가능
      - 특정 리소스에 항상 같은 도메인 배정시에 캐시 적중률 향상
        - 해시방식: 특정 리소스에 동일 도메인 배정 방법 중 하나
          - 해시 함수를 이용해 파일명 숫자 배열로 변경, 숫자에 따라 도메인 결정
- 도메인 분할 기법과 HTTP/2
  - HTTP/1.1의 Head Of Line Blocking 현상으로 도메인 분할기법 고안
    - 클라이언트가 요청에 대한 응답을 받은 후 다음 요청 전송 가능
  - HTTP/2의 멀티플렉싱 기술로 해결) 도메인 분할기법 사용이유 사라짐
    - 도메인 분할기법 사용시 HTTP/2의 헤더압축전송, 우선순위전송, 서버푸시 기능 방해
    - 이전 버전의 브라우저 중 HTTP/2 미지원 존재
  - TCP연결을 병합하는 방식
    - 연결병합: 브라우저가 첫번째 도메인과 맺은 TCP연결을 나머지 도메인에 재사용하는 방식
    - HTTP/2의 기능 저해 않으면서 다중 도메인 사용 방안
    - 고려사항
      - 브라우저가 DNS 확인시 각 도메인은 모두 동일한 IP주소 반환
        - 브라우저는 HTTP/2적용시 도메인명 달라도 각 도메인의 IP 동일하면 먼저 생성된 TCP연결 재사용해 하나의 연결로 처리
      - 동일한 인증서 사용 - 인증서 다를 시 암호화된 연결위해 각 도메인 TLS협상 시도해 추가적인 TCP연결 생성 - 하나의 인증서가 다수 도메인 포함위해 와일드카드인증서, SAN인증서 사용
        > 고려사항 지킬시 HTTP/1.1, HTTP/2 모두 도메인 분할 전송 환경 구성가능
