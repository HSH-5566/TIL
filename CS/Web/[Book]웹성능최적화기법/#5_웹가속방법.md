# 웹에서 가속을 이끌어내는 방법

## 1. 웹 브라우저 현황

- 웹 페이지 경량화&요청 수 줄여도 HTML을 화면에 그리는 것은 웹 브라우저
- => 프런트엔드 최적화의 핵심
  > 브라우저가 페이지를 화면에 렌더링하는 방식 이해&최적화
- 데스크톱 브라우저 점유율
  - 크롬 > Firefox > Safari > Edge Legacy > IE > Other
- 모바일 브라우저 점유율
  - 크롬 > Safari > Sansung Internet > UC Browser > Opera > Android > Firefox > Ohter
- 국내 데스크톱 브라우저 점유율
  - 크롬 > IE > Other
- 국내 모바일 브라우저 점유율
  - 크롬 > Samsung Internet > Safari > Other
    > 점유율 높은 브라우저에 대한 이미지 별도 준비하는 것이 효율적
- 국내 점유율이 높은 IE와 크롬에서 지원하는 이미지 형식, 폰트 타입 다르므로 주의
- 각 브라우저의 웹 페이지 전송, 렌더링 방식에는 큰 차이 없음
  - HTML해석해 이에 맞도록 객체 생성, 화면 크기에 맞춰 그림

## 2. 웹 브라우저 동작 이해하기

- 브라우저에서 웹 사이트 요청하는 순서: 브라우저에서 웹 사이트 주소이용해 서버에서 웹 페이지 다운하기까지의 흐름
  - IP찾기(DNS Resolving): 도메인 서버와 통신해 접속하려는 호스트의 IP찾음
  - TCP연결생성: 해당 IP의 서버와 통신해 TCP연결(HTTPS의 경우 암호화 연결생성위한 협의 단계 추가)
  - 리소스 다운로드: 연결완료 후 브라우저가 서버에서 필요한 리소스 다운해 화면에 표현
    - 방문 페이지의 HTML을 서버에 요청해 다운
    - HTML 구문을 분석(parsing)하며 하위 리소스 차례로 다운(HTML 태그에 참조된 CSS, JS image, font,,)
- 브라우저 아키텍처: 브라우저는 크게 7개의 컴포넌트로 구성
  - 유저 인터페이스: 사용다가 브라우저 통해 상호작용 가능하게 함
  - 브라우저 엔진: 유저 인터페이스-렌더링엔진 사이에서 렌더링 상태 조회, 렌더링 작업 제어위한 인터페이스 제공
  - 렌더링 엔진: 실제 웹 콘텐츠를 브라우저창에 그림(HTML분석해 표현, CSS분석해 웹 페이지 꾸밈)
    > 실제로 HTML 처리해 화면에 렌더링 하는 컴포넌트
    - ex) Webkit(safari), Gecko(firefox), Blink(크롬), Trident(IE) 렌더링 엔진
  - 네트워킹: 네트워크 통해 HTTP요청&응답 받음(DNS조회, TCP연결)
  - UI 백엔드: 콤보박스, 드롭박스,,, 기본적인 UI 컴포넌트 제공
  - 자바스크립트 해석기: JS 분석&해석(V8, Spider Monkey)
  - 데이터 저장소: 데이터 지속성 유지(쿠키, localStorage, indexDB)
- 중요 렌더링 경로
  - 렌더링 엔진의 작업은 선후관계 명확해 단일 스레드의해 수행
    - HTML해석안되면 CSS,JS수행불가, 객체모델 미생성시 브라우저의 화면구성 불가,,
  - 브라우저의 중요 렌더링 경로(Critical Rendering Path)
    1. 브라우저는 처음으로 HTML 구문분석해 DOM 트리 생성
    2. CSS 구문분석해 CSSOM 트리 생성
    3. 두 트리모델 결합해 최종적으로 렌더트리 생성
    4. 브라우저가 렌더트리 기반으로 페이지구조 결정&화면에 표현
  - DOM 트리 생성
    - 브라우저가 가장 먼저 다운한HTML 구문 분석해 태그 하나하나 해석하여 DOM 객체모델로 변환
      - 마크업언어: HTML, XML, 사람 가독성 좋으나 컴퓨터가 이용하기 어려움
      - !DOM: 객체지향적 프로그래밍 언어들로 마크업 문서를 쉽게 프로그래밍 하기위해 표준으로 규정한 프로그램 인터페이스 / 객체 속성, 메소드, 이벤트 등을 정의
  - CSSOM 트리 생성
    - 브라우저가 HTML 구문분석하며 CSS 참조링크 만날 시 해당 CSS 리소스 다운후 구문 분석기가 CSS 분석
    - HTML구문분석과정이 CSS분석에 방해받지 않음: HTML과 다르게 엄격한 구문검사, 구문 분석방법 달라 사용하는 구문 분석기, 동작 스레드 다름
    - !CSSOM: CSS 처리위한 트리구조의 프로그래밍 인터페이스
  - 렌더 트리생성
    - DOM트리와 CSSOM트리 구문 분석완료 시 브라우저가 두 트리 병합
    - !렌더트리: DOM, CSSOM 기반으로 렌더링 위한 최종정보 가진 렌더 객체 생성해 상하관계 트리모양으로 구성
  - 레이아웃
    - 렌더 트리 노드들의 위치 정보 계산
      - 렌더 객체는 사각형 영역 표시 -> 브라우저 창 맨 왼쪽위~아래, 오른쪽으로 이동하며 각 사각형 영역의 너비, 높이 계산
      - 루트노드의 너비: 뷰 포트의 크기
      - 부모 노드의 너비따라 자식 노드 너비 계산, 재귀적
      - 자식 노드의 높이따라 부모 노드 높이 계산, 재귀적
  - 페인트
    - 렌더 트리 정보 바탕으로 브라우저 창에 표현
    - 렌더링위한 정보 모두 존재하므로 GPU이용해 그리면 됨
  - > JS의 경우 DOM, CSSOM 동적으로 변경 가능
    - 변경시 렌더트리 변경&레이아웃, 페인트 재수행
    - JS방해 없이 렌더링 최적화하는 방법 필요

## 3. 브라우저 렌더링 최적화하기

- DOM 최적화 하기
  - HTML의 경우 구문체크에 관대: 문법오류시에도 브라우저에 정상 출력
    - 내부 알고리즘에서 오류 수정: 오류 많을 수록 예외처리위해 메모리,CPU소모
  - 웹사이트 성능 향상
    - > HTML 구문오류 최소화, 간소화
    - > HTML 태그 중첩 최소화: 15단계 이하의 중첩 태그권장
    - > DOM Monster: DOM분석해 최적화 방안 찾는 도구
- JS와 CSS 배치하기
  - JS의 경우 생성된 DOM, CSSOM 변경가능
    - HTML 구문분석기가 HTML해석 중에 JS만나면 다운로드&수행까지 DOM 생성작업 중단 = JS의한 변경완료까지 대기
    - 만약 CSS구문분석, CSSOM생성 작업 중일 경우 완료까지 JS 중단~> 스타일시트 생성전에 이를 JS가 수정하려는 경우 오류발생 = CSS가 JS보다 높은 우선순위
    - > CSS, JS 모두 전체 렌더링 과정 지연 가능한 렌더링 방해 리소스
  - 웹 사이트 성능향상
    - > CSS를 최대한 소스 앞쪽에 배치: CSSOM 빠르게 생성
    - > JS를 최대한 HTML 아래에 배치: DOM, CSSOM생성 후 수행
  - (TOP: CSS, Bottom: JS) vs (TOP: JS, Bottom: CSS) 비교
    - 모든 리소스 다운해 페이지 로딩완료 시점: 2.4s로 비슷
    - 렌더링 시작시점: 0.9s vs 1.5s로 0.5초 차이
- JS 최적화하기
  - JS수행이 렌더링 스레드 작업 방해않도록 별도 스레드로 수행 & 렌더링 작업이 어느정도 끝난 후 스크립트 수행
  - JS제공하는 속성: 분석, 광고용 타사JS에 사용해 메인 페이지 렌더링에 영향않도록 구현
    - aysnc: 구문분석과 동시에 JS다운&수행
      - 지연 수행시 스크립트 간 선후관계 비고려
      - `<script src="async.js" async> </script>`
    - defer: 구문분석 중 별도 스레드로 JS다운&구문분석종료 후 수행
      - 스크립트 호출 순서에 따라 차례로 수행
      - `<script src="defer.js" defer> </script>`
  - 모든 JS가 비동기, 지연처리의 대상 불가
    - JS를 초기 렌더링에 필요한 그룹 / 그렇지 않은 그룹으로 분류해 후자에 async, defer속성 적용
  - 브라우저가 페이지로딩 명시적으로 끝낸 후 나머지 스크립트 수행
    - 브라우저의 페이지 로딩 완료시 onload이벤트 발생
    - onload 이후 스크립트 수행시켜 페이지 로딩시간 단축
- CSS 최적화하기
  - CSS: 렌더링순위 최상위&렌더링 방해하는 리소스(브라우저는 CSS구문분석되고 CSSOM생성까지 렌더링 멈춤)
  - CSS 적절히 분리해 필요한 페이지에 필요한 CSS파일만 포함
  - 첫화면의 CSS파일, 숨겨진 화면의 CSS파일 분리해 후자는 지연수행
    - 미디어 쿼리 이용
      - `<link rel="stylesheet" type="text/css" media="screen and (max-device-width: 480px)" href="style_base.css">`
    - 숨겨진 화면에 적용될 CSS에 onLoad이벤트 발생 후 적용되게 처리
- 이미지 로딩 최적화하기
  - 이미지 로딩 최적화는 다른 방법에 비해 효율적
  - 렌더링에 필요치 않은 이미지 다운 회피방법
    - 해당 이미지가 주요 이미지가 아니면 CSS background-image이용
    - JS를 이용한 지연 로딩 방식
      - 모든 이미지에 적용시 브라우저 프리로더가 이미지 다운 불가해 성능 저하
      - 첫화면에 등장않거나 숨겨진 이미지 다운시 이용
      - !프리로더: 브라우저 자원의 효율적 사용위해 렌더링 스레드와 별도 스레드로 진행, 다운로드 가능 리소스 동시에 다운
        - <`img src="URI">같은 HTHML 표준에 정의된 태그, 속성만 분석해 다운
        - 사용자 정의속성 활용하는 지연로딩방식에 적용불가
    - Progressive JPG 활용
      - 고품질 이미지를 분할 전송하는 방식
      - 브라우저 초기에 저품질 이미지가 보이나 점차 원래 품질 회복
      - 인터넷 속도 느린 구간에서 사용자가 이미지 빨리볼수있는 이점

## 4. 도메인 분할 기법 이용하기

- 도메인 분할 기법: 여러 도메인을 소유한 경우 웹 콘텐츠 병렬적으로 동시에 다운 가능하게 하는 방법
  - > HTTP/1.1 프로토콜 하에서 브라우저의 제약 회피하는 방식
  - HTTP/1.1 프로토콜: 동일 도메인에 순차적 다운로드 방식이용
  - 브라우저는 동일 호스트명의 동시 연결개수 제한함
    - 한 도메인당 6~13개의 TCP연결 생성해 여러 리소스 한번에 다운
    - 브라우저: 최대동시 연결 개수) IE 11.0: 13, 그 외 브라우저: 6
      - 도메인 분할로 2개의 도메인 이용시 6개의 동시 연결지원하는 브라우저의 경우 12개의 연결 가능
  - 추가 도메인 디자인 방법) www.feokorea.com 사이트 운영시
    - www.feokorea.com: 웹 사이트 메인 페이지 및 동적콘텐츠위한 도메인
    - img.feokorea.com: 이미지 호출위한 도메인
    - script.feokorea.com: JS,CSS같은 정적 콘텐츠위한 도메인
    - api.feokorea.com: API 서비스 사용위한 도메인
  - > 하나의 웹 페이지의 리소스 수에 따라 추가할 서브도메인 수 결정
    - 동시 다운 숫자증가시 CPU리소스 사용 증가, CPU리소스 한계시 다운로드 속도 감소
    - 각 도메인에 대한 DNS조회 및 TCP연결을 생성하고 유지하여 페이지 로딩 속도 감소
    - > 테스트 통해 적정 도메인 숫자 결정
  - 도메인 수 결정 시 수에 맞게 리소스 균등분할
    - 특정 도메인에서 대부분의 리소스 다운 시 다른 도메인은 TCP연결 위한 리소스만 낭비
  - 리소스 분류 방법
    - 성격따라 분류
      - JS,CSS,폰트 등 렌더링과 이미지 멀티미디어 리소스 종류 별로 구분, 도메인 별로 균등하게 분배, 관리 간편
    - 동적으로 분류
      - 배포시점에 동적을 도메인 명 결정, 보다 정확한 분배가능
      - 특정 리소스에 항상 같은 도메인 배정시에 캐시 적중률 향상
        - 해시방식: 특정 리소스에 동일 도메인 배정 방법 중 하나
          - 해시 함수를 이용해 파일명 숫자 배열로 변경, 숫자에 따라 도메인 결정
- 도메인 분할 기법과 HTTP/2
  - HTTP/1.1의 Head Of Line Blocking 현상으로 도메인 분할기법 고안
    - 클라이언트가 요청에 대한 응답을 받은 후 다음 요청 전송 가능
  - HTTP/2의 멀티플렉싱 기술로 해결) 도메인 분할기법 사용이유 사라짐
    - 도메인 분할기법 사용시 HTTP/2의 헤더압축전송, 우선순위전송, 서버푸시 기능 방해
    - 이전 버전의 브라우저 중 HTTP/2 미지원 존재
  - TCP연결을 병합하는 방식
    - 연결병합: 브라우저가 첫번째 도메인과 맺은 TCP연결을 나머지 도메인에 재사용하는 방식
    - HTTP/2의 기능 저해 않으면서 다중 도메인 사용 방안
    - 고려사항
      - 브라우저가 DNS 확인시 각 도메인은 모두 동일한 IP주소 반환
        - 브라우저는 HTTP/2적용시 도메인명 달라도 각 도메인의 IP 동일하면 먼저 생성된 TCP연결 재사용해 하나의 연결로 처리
      - 동일한 인증서 사용 - 인증서 다를 시 암호화된 연결위해 각 도메인 TLS협상 시도해 추가적인 TCP연결 생성 - 하나의 인증서가 다수 도메인 포함위해 와일드카드인증서, SAN인증서 사용
        > 고려사항 지킬시 HTTP/1.1, HTTP/2 모두 도메인 분할 전송 환경 구성가능

## 5. 사용자경험 개선하기

- 사용자 경험 지표 바로 알기
  - 웹사이트 성능지표: 브라우저 이벤트 중심에서 사용자 중심 지표로 변화
  - 구글&W3C컨소시엄의 사용자 경험 단계따른 지표 분류
    - 작동하는가
      - Back-end Time / Time To First Byte: 서버에서 첫바이트 수신시간
      - First Contentful Paint: 첫 콘텐츠 첫 픽셀 그려지는 시간
      - Start Render / First Paint: 공백 포함한 첫 픽셀 그려지는 시간
    - 유용한가
      - Visually Ready: 브라우저 화면에 콘텐츠 시각적으로 완료되는 시점
      - Speed Index: 브라우저의 시각적 완료단계 정량적으로 계산
      - Largest Contentful Paint: 주요 콘텐츠 볼 수 있는 시점
    - 사용가능한가
      - First Input Delay: 사용자의 최초입력에 브라우저 반응하는 시간
      - Time to Interactive: 사용자와 상호작용 가능해지는 시간
    - 즐거운가
      - Long Task Time: 50ms 이상의 장기작업 소요 시간
- 사용자 요청에 빠르게 반응하기
  - 사용자가 URL 클릭 후 1초안에 반응 & 2초안에 페이지로딩 완료시 사용자 이탈 방지
  - TTFB(Time To First Byte): 300~500ms가 이상적, 빠른 서버 응답
    - HTML 주석, 공백,, 불필요 코드 제거해 전송 바이트크기 감소
    - HTML페이지 캐시해 서버처리시간 최소화
  - 브라우저 렌더링 최적화 기법
    - CSS, JS 크기 줄이기: 공백,주석제거 & 파일분리 통해 필요한 리소스만 다운 (HTTP/2의 경우 요청수 상관없이 전체 리소스 크기 줄여야 다운로드 성능 향상)
    - CSS,JS에서 중요 리소스 구분: 화면안쪽(Above the fold)의 웹 콘텐츠 렌더링위한 파일
    - 중요 리소스는 빠르게 로딩: 리소스 힌트인 preload사용 || HTTP/2 서버푸시사용
      - !서버푸시: 최초 HTML다운되는 시점에 발생해 preload보다 빠르게 다운
    - 중요하지않은 리소스 로딩 지연: JS에 async, defer속성 || onLoad이벤트 이후 수행하도록 지연, CSS의 경우 JS이용해 onLoad이후 수행되도록 지연
- 사용자 시선 붙잡기
  - 2초안에 의미있는 콘텐츠(Hero이미지) 표현해야 사용자 이탈률 감소
  - Hero이미지 지연되는 이유
    - 페이지 로딩시간 개선위해 모든 이미지 지연로딩
      - 지연로딩이 적용된 이미지는 preload 대상에 미포함
      - Hero이미지 제외한 이미지에 이미지 지연로딩 적용
    - CSS의 background-image속성으로 Hero이미지 지정
      - 해당 속성으로 지정된 이미지는 CSS분석후 DOM에 적용될 때 다운, preload에도 미적용
      - <`img>태그로 지정된 이미지는 HTML분석과 함께 다운
  - Hero이미지 다운 최적화
    > 1. HTML의 <`img>, <'picture>이용해 직접다운, 지연로딩 미적용
    > 2. CSS background-image속성에 Hero이미지 미사용
    > 3. CSS배경 이미지로 Hero이미지 사용시 리소스힌트인 preload사용해 일찍 다운
  - 메인 텍스트의 지연
    - 폰트: CSS의 font-face통해 로딩, 이미지보다 다운시점 늦음
    - 폰트 경량화
      - preload이용해 빠르게 다운 필요하나 한글폰트의 경우 파일 크기 매우 큼
      - 폰트 파일 경량화 후 preload 이용: 서브세트 생성
      - ex) fonttools 라이브러리
      - 서브세트로 만든 폰트파일을 WOFF2로 압축해 이용
    - 폰트 로딩 방식
      - 크롬: 웹 폰트 다운 3초 대기 후 다운안됐을 시 시스템 폰트 이용, 최종적으로 웹 폰트 다운 시 대체
      - FOIT: 웹 폰트 완전다운 후 텍스트 나타내는 방식
      - FOUT: 시스템 폰트 사용 후 웹 폰트 다운시 대체하는 방식
        - 사용자에게 빠르게 메세지 전달 가능
        - CSS font-face룰에서 `font-display: swap`
        <pre>
          <code>
          @font-face{
            font-family: MyFont;
            src: url(/path/myFont.woff) format('woff2'), font-weight: 400;
            font-style: normal;
            font-display: swap;
          }
          </code>
        </pre>
- 사용자 상호 작용 방해하지 않기
  - 시각적 완성후 상호작용 원할해야 사용자의 이탈률 감소
  - 사용자의 상호작용 측정지표
    - Time to Interactive: CPU유휴 시간, 네트워크 사용량,, 클라이언트의 물리적지표의해 결정
      - 다운 리소스양과 수행 스크립트 감소하는 것 중요
    - First Input Delay
  - 타사 리소스: 광고, 마케팅 분석, 성능 측정 목적으로 페이지에 로딩
    - 타사 도메인에서 다운, 관리되므로 다운속도 문제시 직접개선 어려움
    - 성능검증, 점검, 사용 완료시 제거,,, 필요
    - RequsetMap, Ghostery: 타사 리소스 현황파악 툴
    - 타사 리소스가 웹 사이트에 영향 주지 않게하는 방법
      - 해당 리소스 호출 스크립트를 비동기적으로 다운
      - 그렇지않으면 단일실패지점(SPOF) 발생 가능
        - 타사호스트가 리소스 다운요청에 미응답 시 웹 사이트 로딩지연
    - SPOF-O-Matic: 타사 리소스의 잠재적 장애요소 확인 플러그인
