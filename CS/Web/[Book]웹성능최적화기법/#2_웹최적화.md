# 웹 최적
1. 웹 최적화: 최고의 성능 만드는 최적화 조건 갖추는 것
    - 프런트엔드 최적화: 웹 UI/UX와 관련
        - 브라우저에서 콘텐츠 다운, 로딩, 렌더링시 속도 빨라짐
        - 웹의 성능은 프런트엔드에 좌우 ~> 대부분의 응답 프런트엔드에서 발생
        - 사용자 환경에 따라 변화
        - 대표적 방법
            - 스크립트 병합해 브라우저 호출 수 줄임
            - 스크립트 크기 최소화해 바이트 자체 감소
            - 스크립트 gzip으로 압축해 전달
            - WebP 등으로 브라우저 이미지 형식 최적화
            - 이미지 손실, 무손실 압축
            - Cache-Control 응답 헤더 이용해 브라우저 캐시 사용
            - 도메인 수 줄여 DNS조회 최소화
            - DNS정보 미리 읽어오기
            - CSS는 HTML상단, JS는 HTML하단에 위치
            - 페이지 미리 읽어오기(page prefetching)
            - 타사 스크립트가 웹 성능 방해않도록 조정
    - 백엔드 최적화: 웹 UI를 로직에 맞게 만듦
        - 웹서버, WAS, DB, 로드밸런싱, DNS서버 등을 튜닝해 정상출력 만듦
        - 프런트엔드 최적화보다 가시적인효과가 떨어지나 네트워크 정상사용, 콘텐츠 전달위해 반드시 필요한 요소
        - 대표적 방법
            - DNS 응답 빨라지도록 서버 증설 및 DNS정보 최대한 캐싱
            - 웹 서버가 있는 데이터 센터의 네트워크 출력, 대역폭 증설
            - 웹서버, WAS의 CPU/RAM 증설
            - 프록시 서버 설정해 웹 콘텐츠 캐싱
            - CDN사용해 인터넷상에 콘텐츠 캐싱
            - DB정규화로 디스크I/O최적화
            - DB캐싱으로 응답 빠르게
            - 로드밸런싱 통해 가장 성능 좋은 웹서버로 요청 연결
            - 웹 애플리케이션 로직을 가볍고 빠르게 개발
    - 프로토콜 최적화: HTTP/HTTPS 프로토콜 자체 효과 극대화
        - 웹 서버가 클라이언트에게 콘텐츠를 최대속도, 최저지연시간으로 전달 가능
        - 웹 콘텐츠 더 빠르게 요청&응답하도록 프로토콜 업그레이드
2. TCP/IP 프로토콜
    - TCP성능에 웹 성능도 영향받음
    - HTTP: TCP/IP 프로토콜의 일종으로 웹에서 콘텐츠 전달위해 사용
        - 응용계층: 실제 네트워크 상 SW와 사용자의 상호연동 담당, 전송계층을 바탕으로 운용
    - 대표적인 성능지표
        - 대역폭: 시간당 전송량 - 특정시간 동안 보낼 수 있는 네트워크 트래픽 양
            - ex) 크기 큰 파일 다운시 완료시간은 Clint-Server사이 대역폭에 영향받음
        - 지연시간: client-server간 콘텐츠 전달하는 물리적인 시간
            - 브라우저의 콘텐츠 해석, 렌더링시간은 지연시간에 포함안됨
            - RTT: client-server 두 호스트 모두 왕복하는데 걸리는 지연시간
                - 스트리밍 서비스에 영향 -> 가변 스트리밍방식 이용
    - TCP 혼잡제어: TCP 네트워크 통신량 조절해 TCP 네트워크 혼잡 방지
        - TCP 성능저하요소 해결하는 기술
        - 패킷보내는 쪽에서 네트워크에서 수용가능한 양 파악해 그만큼의 패킷만 전송
        - 대표기술
            - 느린시작: CWND의 초깃값 작게해 전송 후 정상수신응답 받으면 그 두배를 전송하는 것을 패킷유실 전까지 반복, CWDN 크기 파악
                - !CWDN: 혼잡 윈도우, 전송가능한 버퍼의 양
            - 빠른 재전송: 먼저 도착해야할 패킷 대신 다른 패킷 도착시에도 ACK전송, 중복된 ACK통해 손실된패킷 감지해 재전송, 중복패킷3개 받을시 손실된 패킷 재전송&CWND크기줄임(혼잡제어필요상황)
            - 흐름제어: TCP송신자가 데이터 빠르게/많이 전송해 수신자 버퍼 오버플로되는 현상 방지, 송신자가 데이터 전송하는 속도와 애플리케이션 프로세스읽는 속도를 유사한 수준으로 만들어 트래픽 수신속도, 송신속도 일치 시킴
3. HTTP프로토콜
    - 웹은 HTTP프로토콜 통해 전달
    - 웹 환경변화에 대응하는 기능 추가 업데이트 지속
    - HTTP 지속적 연결
        - 3-way handshake: client-server사이 syn-syn/ack-ack으로 TCP연결
            - 매번 TCP연결 맺고 끊음 -> TCP연결 재사용 필요
        - keep-alive: TCP연결되면 완전히 끊어지기 전까지 맺어진 연결 지속적 재사용
            - 연결 재사용
        - HTTP/1.1부터 keep-alive가 기본지원
            - Connection: keep-alive -> default로 사용
            - Connection: close -> 지속적 연결 미사용
                ```
                curl -v -o out https://www.akamai.com -H "Connection: close"
                ```
            - !curl: HTTP요청과 응답을 브라우저와 유사하게 커맨드라인 형식으로 실행할 수 있는 어플리케이션, HTTP요청이나 웹서버 응답을 헤더와 페이로드로 나누어 살필 때 유용
            - TCP연결 계속 증가시 자원고갈 -> 서버성능고려해 지속적연결사용여부 결정
                - ex) 메인페이지와 같은 다수의 클라이언트 접속페이지
            - 지속적연결통한 단일시간간 TCP연결 수 감소시켜 자원절약&네트워크혼잡,지연감소
            - 파이프라이닝 기술 사용시 지속적연결 필수
        - HTTP/2는 멀티플랙싱 기술
            - 단일 TCP연결통해 client-server사이 응답지연없이 스트림 형태로 다수의 HTTP요청, 응답가능
            - 지속적 연결 고민 필요없음
        - HTTP 파이프라이닝: 먼저보낸 요청 응답없이도 다음 요청 병렬적으로 수신자에게 전송해 중간에서 응답지연 발생시에도 client가 먼저 server응답 받을 수 있어 전체적으로 빠른 웹로딩 구현
            - HTTP 선입선출 방식 단점 극복: 기존 HHTP요청, 응답 여럿일 때 하나의 응답 지연시 나머지 요청, 응답 모두 지연
4. DNS
    - 인터넷 호스트명을 IP주소로 변환, 클라이언트와 서버가 이해가능
    - IP주소로 만들어진 웹 사이트의 경우 DNS불필요
    - DNS 질의, 응답 성능 나쁘면 웹 사이트 로딩에 영향
    - DNS작동원리
        - 도메인 구조 계층따라 각각의 DNS서버가 관여
        1) 로컬 DNS서버로 질의: 로컬DNS서버에 주소창의 도메인(www.exam.com) 대한 1차질의
            - 해당 도메인 IP주소가 이전에 질의&캐시주기 값 남아있을 시 캐싱한 IP주소 반환
            - !로컬 DNS: 사용자와 인접한 DNS, ISP업체나 DNS전문 서비스업체가 관리
        2) 루트 DNS서버로 질의: 소유하지 않은 도메인 정보대한 질의시 로컬DNS에서 루트DNS에 도메인대해 질의, 해당 정보없는 루트DNS는 .com도메인 서버의 IP정보 알림
            - !루트 DNS: 전체 도메인 관장, ICANN기관에서 관리
        3) .com DNS서버로 질의: 로컬DNS가 .com DNS에 도메인 질의, 해당 정보없는 .com DNS는 exam.com 네임 서버의 IP정보 알림
            - !.com DNS: .com 도메인 관장
        4) exam.com DNS서버로 질의: 로컬 DNS가 exam.com DNS에 도메인 질의, exam.com DNS는 자신이 알고있는 www.exam.com 네임서버의 IP정보 알림
            - !exam.com DNS: www.exam.com 도메인 관장
        - => 반복적 질의: 도메인 구조 계층으로 나눠진 역할 따라 순차적 DNS질의를 반복해 값을 가져오는 프로세스 과정
        - 웹서비스 운영업체의 경우 exam.com 서버부터 관여해 DNS 전문 업체 서비스 받거나 분산된 DNS서버 직접 운영해 DNS성능 향상
    - 사용 중인 도메인 확인
        - 크롬브라우저 - 개발자도구 - Source
        - 해당 페이지에서 사용 중인 모든 도메인 호스트명&가져온콘텐츠 확인가능
        - 특정업체의 서비스에서 문제 발생치 않도록 지속적 모니터링 필요
        - 사용중인 특정 모듈업체 DNS 조회 불가능하거나 느리면 다운로드하여 웹 서버에 설치
    - 도메인 운용방법
        - 공통 상위 도메인 사용해 DNS질의를 최소화
            - 도메인 질의 담당하는 네임서버에 캐싱된 정보 이용 가능
            - HTTPS 사용을 위한 SSL 인증서를 와일드카드 형식으로 하나만 생성해도 모든 도메인에 사용가능
        - HTML의 DNS 프리페치 기능: 하나의 웹 페이지에 다수의 도메인 호스트명이 섞여 있을 때 웹 문서 여는 시점에 멀티스레드 방식으로 미리 DNS 조회하여 빠르게 IP주소 불러오는 기술
            - 브라우저가 웹 콘텐츠 다운과 동시에 DNS 조회
            - Can I use 사이트: 브라우저의 기능 지원 확인 가능
            ```
            <!--DNS미리 조회하기-->
            <link rel="dns-prefetch" href="//api.feo.com">
            ```
5. 브라우저
    - HTTP, DNS를 사용해 사용자가 원하는 웹 콘텐츠(HTML, 이미지,,) 전달하는 SW
    - 웹 성능 최종테스트&디버깅 작업은 브라우저 통해 수행: 브라우저 동작속도와 웹성능 관계
    - 내비게이션 타이밍 API: 웹 사이트 성능측정시 사용가능한 데이터 제공
        - 종단간(end-to-end) 대기시간(latency) 정보제공
        - window.performance 개체의 속성으로 사용가능
        - performance.timing 이벤트 속성: 페이지 로딩 흐름 순서따라 정의
            - Prompt for unload
                - navigationStart: 이전 페이지가 unload시작한 시점
            - unload
                - unloadStart: 이전,현재 페이지 동일시 unload이벤트 시작직전시점
                - unloadEnd: 이전,현재 페이지 동일시 unload이벤트 마친바로다음시점
            - redirect
                - redirectStart: HTTP에서 페이지 재전송시 시작 시점
                - redirectEnd: HTTP에서 페이지 재전송응답의 마지막 바이트받은 시점
            - App cache
                - fetchStart: HTTP요청으로 새로운리소스 불러오는 시점, HTTP요청 애플리케이션이 캐시지원시 캐시존재 확인하는 시점
            - DNS
                - domainLookupStart: 웹 사이트도메인 DNS로 IP검색시작하는 시점
                - domainLookupEnd: DNS조회 종료시점
            - TCP
                - connectStart: 브라우저가 서버와 연결 시도하는 시점
                - SecureConnectionStart: HTTPS로 접속시 브라우저가 서버와 연결시도하는 시점
                - connectEnd: 브라우저가 서버와 연결끊는 시점
            - Request
                - requestStart: 브라우조가 접속한 서버나 애플리케이션 캐시 시스템에 문서 요청한 시작시간
            - Response
                - responseStart: 브라우저가 서버나 캐시시스템에서 응답 데이터의 첫번째 바이트 받은 시간
                - responseEnd: 브라우저가 서버나 캐시시스템에서 응답 데이터의 마지막 바이트를 받은 시간
            - Processing
                - domLoading: 브라우저가 웹 페이지 문서 만들기 시작하는 시점
                - domInteractive: 브라우저가 웹 페이지 문서 준비상태를 interactive로 변경하는 시점
                - domContentLoaded: 웹 페이지문서에서 DOMContentLoaded 이벤트 호출되는 시점
                - domComplete: 웹 페이지 문서가 준비상태를 complete로 변경하는 시점
            - onLoad
                - loadEventStart: 웹 페이지의 load이벤트 발생시점
                - loadEventEnd: 웹 페이지의 load이벤트 완료 시점
        - navigation: 사용자가 페이지를 어떻게 탐색하는지 조사
        - timing속성: 탐색, 페이지 로드 이벤트 대한 데이터 가짐
        - 내비게이션 타이닝 API 지원 브라우저: 크롬
        - window.performance.navigation 객체
            - 페이지 재전송속성, 앞뒤이동버튼&URL이 어떤 페이지로딩 발생시키는지 확인하는 속성 가짐
            - redirectCount: 페이지 내 재전송 횟수
            - type: 사용자가 웹 페이지에 접속한 방법 정보
                - TYPE_NAVIGETE: 0, 링크, 북마크, 전송, URL 타이핑 등
                - TYPE_RELOAD: 1, 브라우저 새로고침
                - TYPE_BACK_FORWARD: 2, 뒤로가기 버튼
                - TYPE_RESERVED: 255, 그외의 방법
        - pageLoadTime: 페이지 전체로드 시간(loadEvent - navigationStart)
            - 예상보다 클 시 웹 사이트 최적화&콘텐츠수,크기 줄여 로딩빠르게
        - connectTime: HTTP요청-응답 걸린시간(responseEnd - requestStart)
            - 기기나 네트워크 종류관계없이 클 경우 웹 서버를 네트워크에 빠르게 연결할 수 있는 방법 탐색
            - ex) 웹 서버위치한 데이터 센터 사이 지연현상 발생원인 탐색, 전달망 품질 개선