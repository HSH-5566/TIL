# 캐시최적화

## 1. 캐시

- 캐시: 콘텐츠 요청에 빠르게 응답위해 서버-클라이언트 사이 응답 콘텐츠의 사본 저장하는 공간
  - 사용자의 같은 요청에 응답하는 리소스 동일시 이용
  - 서버-클라이언트 사이에 존재, 서버 성능향상시키는 역할
  - 웹의 경우 HTML, CSS, JS 등 정적 콘텐츠 많음
- 캐시 서버: 캐시를 유지, 처리하는 별도의 서버
  - 캐시서버의 종류
    - > 기능상 차이 있으나 캐시 컨트롤 기본 원리는 동일
    - 브라우저 캐시(로컬캐시)
      - 브라우저에 위치
      - 한번 다운한 리소스를 재사용해 사이트 로딩 빠르게 함
    - 프록시 캐시
      - 브라우저와 ISP에 위치
      - 조직내 사용자가 접속하는 웹 사이트 리소스 캐시해 네트워크 연결과 대역폭 사용률 감소, 사용자 웹 사이트로딩 빠르게 함
    - 트랜스패어런트 캐시
      - ISP에 위치
      - ISP에서 이를 사용해 ISP간 대역폭 낭비 방지
    - 리버스 프록시 캐시(웹 캐시)
      - ISP와 웹서버에 위치
      - 원본 서버로 향하는 트래픽 대역폭 감소&사용자 응답 개선
      - 서버에서 성능향상위해 별도로 사용
      - 웹 캐시: 리버스 프록시 서버(웹서버)에 캐시 기능 추가해 리버스 프록시 캐시서버로 이용
        - Apache HTTP Server: mod_cache, mod_cache_disk, mod_file_cache 모듈 활성화해 캐시서버로 활용 가능
        - Apache Traffic Server: 오픈소스 웹 캐시서버, 성능&확장성 뛰어난 웹 캐시 서버
        - Nginx: 웹 서버 중 하나로 콘텐츠 캐시 기능 제공
        - Varnish Cache: 캐시 통한 HTTP가속 목적으로 개발된 오픈소스 소프트웨어, 캐시 및 가속 기능 제공

## 2. 웹 캐시 동작 원리

- 웹 캐시
  - 웹 서버와 웹 브라우저의 중간에 위치, 최초 원본 콘텐츠 요청을 최종서버에 보내 응답받고 복사본 만들어 저장해 사용자에게 응답
  - 같은 콘텐츠 요청 시 복사본을 사용자에게 전달
  - > 원본서버로의 트래픽 줄이고 사용자 요청대한 반응속도 향상
  - 모든 웹 콘텐츠 캐시는 불가
    - 개인정보 보호
  - 콘텐츠 변경시 감지하여 원본서버에 요청
- 캐시서버: HTTP/1.1 규격을 기반으로 동작
- HTTP
  - 인터넷에서 데이터 주고받기 위한 클라이언트/서버 모델의 프로토콜
    - 클라이언트가 특정 URL 요청을 서버에 전달
    - 서버에서 요청 처리해 URL에 해당하는 응답 클라이언트에게 전달
    - 브라우저(클라이언트) / 웹서버(서버) / 프록시서버(클라이언트 / 서버)
  - OSI 7계층의 Application 레벨 프로토콜, TCP/IP위에서 동작
  - TCP Connection 맺어지면 HTTP는 어떤 종류의 데이터든 전송가능
  - > 특징
    - 클라이언트 서버 모델
    - 비연결성, 상태유지않는 프로토콜 (Connectionless, Stateless)
    - 클라이언트와 서버간 HTTP메세지 주고받으며 통신
    - HTTP 메세지 = 헤더 + 바디
    - TransportLayer프로토콜로 TCP사용, 일반적으로 80포트(SSL은 443포트)
  - HTTP메세지
    - 헤더: 메세지 전송 및 처리에 필요한 데이터 -메세지 전송할 호스트명, URL패스...
    - 페이로드: 서버가 실제 전송하려는 데이터
      - html, 이미지 ...
- HTTP의 캐시제어 방식

  - HTTP/1.1부터 명시적으로 캐시제어가능한 헤더 추가: Cache-Control
  - 캐시제어 목적
    - 원본서버로 요청하는 수 최소화: 네트워크왕복수 감소 = 응답속도단축
    - 완전한 콘텐츠 응답안해도 됨: 네트워크 대역폭, 리소스 낭비 감소, 비용 효율화
  - HTTP헤더

    - Expire: HTTP/1.0에서 원본서버 콘텐츠 유효기간 설정
      - 명시적 캐시제어않고 브라우저와 같은 캐시서버에서 콘텐츠 언제까지 저장할지 판단
      - 원본서버에서 Expire, Date헤더(요청대한 응답작성시점) 함께 전송
        - 원본서버 시간 기준으로 생성, HTTP Date형식
      - 응답의 캐시유지시간(TTL): Expire - Date
    - ETag: 원본서버가 리소스 식별위해 부여하는 고유번호
      - 캐시서버에서 원본서버의 리소스가 만료, 갱신해야하는지 판단
      - 따옴표내 임의의 문자조합: ETag: "2sad23 da2312d"
      - Strong ETag: 모든 리소스에 유일한 값, 생성 어렵
      - Weak ETag: 간단하게 생성, 신뢰도 감소, 원본서버에서 ETag역할 중요치 않을 시 w/를 붙여 캐시서버에 전달
        - w/: 해당 값이 유일하지 않을 수 있으나 괜찮다는 의미
    - Cache-Control
      - 캐시서버에서 Cache-Control헤더 사용한동작순서
        1. 첫 요청에 캐시된 응답없어 캐시서버가 원본서버에 그대로 요청전송
        2. 첫 요청 대해 원본서버에서 응답생성, 객체 언제까지 유효한지 HTTP헤더에 명시
        3. 캐시서버가 해당 요청대한 캐시키, 응답 저장 및 만료일 설정 후 요청자에게 응답 전송
        4. 같은 요청이 만료일 지나지 않았을 시 캐시에 저장된 응답 사용자에게 전송
        - > 사용자에 대한 응답시간 단축
      - max-age: HTTP/1.1애서 콘텐츠 캐시 유지시간 정의(유효기간)
        - 원본서버가 이를 이용해 캐시에서 특정 콘텐츠 얼마나 유지해야하는지 명시적으로 설정
        - 기간 지날시 캐시서버가 원본서버에 변경여부 체크 || 갱신
      - s-maxage: CDN과 같은 공용캐시주기 관리
        - 사용중인 모든 CDN캐시 주기 일괄적으로 설정, 변경 가능
        - CDN업체가 헤더 지원하는지 확인하고 이용
      - public: 해당 응답이 모든 캐시서버에 캐시가능, 사용자제한 없이 모든 사용자에게 응답 전달 가능
      - private: 요청한 사용자만 캐시가능, CDN같은 범용캐시서버에서 캐시시 응답을 모든 사용자에게 공유불가
        - 개인정보 보호가 아닌 응답메세지를 어디에 캐시할 것인지 지정
      - no-cache
        - 요청헤더
          - 브라우저가 원본서버나 캐시서버에게 캐시된 응답 받지않음
          - 캐시서버가 원본서버에서 최신의 응답을 받아 사용자에게 전달
          - <-> max-age=0: 캐시된 콘텐츠의 변경이 있는지 검증 후 유효하면 캐시에 있는 값 반환
        - 응답헤더
          - 원본 서버가 캐시서버에게 캐시된 응답 전송전 원본서버 확인하도록 강제
          - 매 요청마다 캐시된 복사본과 원본 서버와 검증 강제
          - max-age=0과 동일
          - 특정 헤더만 캐시않도록 설정: 지시자 옆에 캐시안하려는 헤더 나열, 해당 헤더를 제외한 응답을 캐시서버가 캐시
      - no-store: 서버가 로컬 저장소에 메세지 저장않도록 지시
        - 응답 메세지가 저장소에 저장되는 것 금지
        - 캐시 데이터의 예기치않은 유출방지: 개인정보보호수준 향상되나 완벽한 보안 매커니즘아님
        - <-> no-cache: 응답 항상 최신으로 유지하나 로컬 저장소에 저장방지 안함

    > Expire, Cache-Control: 원본 서버 콘텐츠의 캐시 TTL결정

    - HTTP/1.0기반의 캐시서버, 브라우저는 Cache-Control:max-age 미지원하므로 원본서버는 모든응답에 두 헤더 모두 표시
    - HTTP/1.1지원하는 캐시서버는 HTTP응답에 두헤더 모두 명시시 Cache-Control우선 사용

- 캐시 유효성 체크
  - 사용자가 콘텐츠를 캐시에 요청시 저장된 응답의 age > max-age면 응답 신뢰 불가
    - 캐시가 원본서버에 요청해 새응답(콘텐츠+max-age재설정)
  - 조건부요청
    - 캐시된 내용과 동일 응답 서버에서 전송시 서버자원, 네트워크 대역폭 낭비 -> 비효율적 요청/응답 방지하는 메커니즘
    - 저장된 응답 TTL만료시 TTL주기 동안 콘텐츠 변화했을때만 새 응답 생성하도록 요청
      - 웹 캐시에서 조건부요청을 서버에 전송
      - 변경 존재시 200응답코드 & 변경된 콘텐츠를 응답 본문에 포함해 전송
      - 변경 없을 시 304응답코드(Not-modified)만 헤더에 설정해 전송
        - 응답에 본문이 없어 서버, 네트워크 자원낭비 방지
  - 조건부요청 방법
    - 시간기반 조건부 요청
      - 요청대한 원본 서버의 콘텐츠가 캐시에 저장 후 콘텐츠 변경을 콘텐츠의 최종변경시간 중심으로 확인
      - 원본서버가 콘텐츠 응답 전송시 Last-Modified 헤더에 최종변경날짜, 시간 작성해 전송
      - 캐시가 최초 요청대한 응답 저장, TTL 시간지난 후 같은 요청시 원본서버에 '최종 변경시간 후 변경사항존재시 전체응답 재요청' & If-Modified-Since헤더에 Last-Modified값 복사해 원본서버에 전송
    - 콘텐츠기반 조건부 요청
      - 요청대한 원본 서버의 콘텐츠가 캐시에 저장된 후 변경됐는지 콘텐츠 고윳값 중심으로 확인
      - 교윳값: 해시값이용, ETag헤더
      - 캐시가 최초 요청대한 응답 저장, TTL 시간지난 후 같은 요청시 원본서버에 '해당 콘텐츠와 일치하는 고윳값없을 시 전체응답 재요청' & If-none-match헤더에 ETag값 복사해 원본서버에 전송
    - > 변경사항존재시: 200코드 & 본문이 존재하는 완전한 응답
    - > 변경사항없을시: 304코드만 있는 응답헤더만 전송
- 캐시 콘텐츠 갱신

  - 웹 사이트 개편 || 콘텐츠 급한 변경시 캐시 복사본 강제 갱신필요
  - 퍼지: 저장소를 완전히 지우는 방식

    - 캐시서버에서 캐시 모두 지우는 명령어, API 제공
    - 많은 캐시 퍼지시 원본서버에 자원 충분한지 확인: 캐시안된 요청이 한번에 원본 서버에 몰려 서버리소스 부담
      - 단계적으로 나누어 퍼지 || 무효화방안 이용
    - 프로모션, 새로운 페이지 오픈시: 테스트 툴 이용해 서비스할 웹 페이지 리소스 캐시에 미리 저장

  - 무효화: 조건부 요청을 통해 캐시된 리소스 중 변경있는 리소스만 새로 갱신
    - Cache-Control 이용: 캐시서버 내용 강제로 무효화
      - `Cache-Control: max-age=0, must-revalidate`
    - 원본서버, 웹 캐시서버에서 이용시 퍼지와 같이 새 콘텐츠 받으려는 트래픽 증가
      - 퍼지와 다르게 대부분 If-modified-since, if-none-match 요청, 변경된 리소스만 전체 콘텐츠 반환
      - 네트워크 대역폭낭비 감소
  - 비동기 캐시 갱신
    - 시용자가 기한 만료된 콘텐츠 요청전 미리 최신 콘텐츠 받아두는 방법
      - `Cache-Control: max-age=600, state-while-revalidate=30`
      - 600초간 캐시에 저장된 리소스 받고 이후 30초간은 만료되었으나 여전히 캐시된 리소스를 서비스 받음
      - 캐시는 그동안 서버와 통신해 새로운 콘텐츠 비동기적으로 받아옴

## 3. 캐시 최적화 방안

### 캐시의 목적

- 원본 서버로의 요청 수, 네트워크 대역폭 낭비 줄여 많은 트래픽 처리해야하는 원본서버 부담 감소
- 캐시서버와 원본서버 사의의 RTT감소
- > 사용자 경험 향상 == 프런트엔드 성능 향상
  > 캐시사용 최대화 3가지 기본원리: 최대한 많이, 오래 ,가까이 캐시

### 캐시 가능한 콘텐츠 구분하기

- WebPageTest: 해당 웹페이지의 구성, 캐시가능한 파일 확인가능
  - Enter a Website URL에 URL기입 후 Content Breakdown탭: 페이지 구성하는 콘텐츠 종류별 요청, 바이트 비율 상세 확인가능
- 정적콘텐츠: URL호출시 변함없이 같은 응답
  - 이미지, CSS, JS,,,
- 동적콘텐츠: 사용자가 요청시 서버의해 다시 생성, 응답되는 콘텐츠로 서버에서 HTTP요청, 입력시간 등의 변숫값따라 콘텐츠 동적생성해 응답
  - Ajax이용한 XHR요청, 개인화된 웹페이지, JSP&ASP&PHP로 만든 웹
- 캐시하기 어려운 콘텐츠
  1. 개인화된 콘텐츠
  - 접속하는 사용자에 따라 달라지는 콘텐츠, 원본서버에서 가공
  2. API호출, Ajax요청대한 콘텐츠
  - 사용자의 동적정보를 원본서버에 전달해 결과값 반환
  - 단, 입력값 동일시 결과값 동일한 콘텐츠는 캐시 가능
  3. Beacon전달, 쿠키설정위한 호출
  - 사용자정보 수집이나 브라우저 쿠키설정위해 작은 이미지 호출하는 경우 존재, 해당 요청대한 응답 캐시에 저장시 원본서버에 정보 보내거나 받을 수 없음

### 올바른 캐시 정책 설정하기

- 캐시 가능한 콘텐츠 구분 후 각 콘텐츠대한 캐시 정책 수립: 캐시제어기술 이용
- 리소스를 같은 타입끼리 그룹화, `아래의 순서`로 하위그룹 분리 후 캐시정책 수립
  1. 캐시 가능한 콘텐츠인지 판단
  - 보안에 민감한 정적페이지는 캐시불가
  - 동적페이지라 해서 항상 캐시불가는 아님
  - > 캐시할 수 없는 콘텐츠는 응답헤더에 `Cache-Control: no-store`
  2. 캐시 가능한 콘텐츠는 매번 원본 서버에 변경사항 확인해야하는지 판단
  - 정적이나 자주 변하는 콘텐츠, 변경에 민감한 리소스
  - > 응답헤더에 `Cache-Control: no-cache` 또는 `Cache-Control: max-age=0`
    - 응답 리소스 미변화시 304코드만 응답해 네트워크대역폭낭비 감소
  3. 캐시할 콘텐츠의 성격 판단
  - > 모든 사용자에게 공통으로 사용 `Cache-Control:public`
  - > 개인화된 콘텐츠 `Cache-Control: private`
    - 일반적인 웹 캐시에서 해당 콘텐츠 캐시불가, 개인 브라우저에서만 캐시
  4. 캐시 주기 설정, max-age 추가

### 캐시 주기 설정하기

- 캐시정책 수립 후 캐시할 시간 결정
  1. 캐시주기는 콘텐츠 타입별로 다르게 설정
  - 미디어파일(이미지, 영상): 변경 적음, 캐시주기 1년
    - 미디어파일 변경시 내용수정보다 새로운 미디어파일로 이름 바꾸고 링크변경 경우 많음
    - 링크 변경시 캐시서버가 해당 콘텐츠 불러와 캐시
  2. 링크변경없이 이미지 내용만 변경시 캐시 무효화로 해당 이미지만 캐시에 업데이트
  - 웹 리소스파일(CSS,JS,font): 변경이 얼마나 자주인지 따라 다르게 설정, 범위안에서 가능한 길게
    - font: 업데이트 비교적 드움
    - Css, JS: 불규칙하게 수시로 변경됨
  - 변경주기 잦아도 짧게라도 캐시주기 정해 캐시하는 것이 성능유리
  3. 모든 정적 파일대해 캐시주기 길게 & 캐시주기 수동 관리
  - 파일명 뒤에 해시값 자동으로 붙여 파일명 관리
    - `pacak.b23sad30.js`
    - 한 폴더내 여러 버전의 유사파일 쌓여 파일 공간 주기적 관리
  - 파일 요청시 쿼리 스트링으로 버전 지정
    - `core.min.js?2018103123`
    - 같은 파일면 사용하며 수동으로 콘텐츠 업뎃
    - 필요시 마다 쿼리 스트링의 버전 변경
- 수시 반영위해 캐시 가능한 정적리소스 캐시않으려 할 경우
  - `Cache-Control: no-store`보다 `Cache-Control: no-cache, max-age=0` 사용 권장
    - 변경 존재시만 캐시에 업데이트해 네트워크 대역폭 낭비 감소
- 캐시주기 조절
  - 파일 시스템에서 최종변경 일자확인
  - 브라우저 개발 툴, curl이용한 HTTP헤더의 Last-Modified Date확인
  - > 정보를 토대로 가능한 더 오래 캐시하도록 캐시주기 조절

### 캐시에 적합한 디렉터리 구조 구성하기

- 캐시 친화적 디렉터리 구조
  1. 캐시 가능한 콘텐츠를 별도 폴더에 분류해 관리
  - 정적 콘텐츠를 `/static` 아래에 배치
    - 캐시서버를 `/static/*`처럼 간소설정 가능
    - 캐시 가능 콘텐츠 누락 실수 감소
    <pre>
    /static/image
    /static/css
    </pre>
  2. 캐시 주기별로 나누어 구성
  - 특성에 따라 캐시주기 다름
    - 라이브러리에 사용되는 JS는 변경 적음
    - 특정 모듈에 사용되는 JS는 변경 많음
    <pre>
    /static/js/lib
    /static/js/module/A
    </pre>
  3. 동일 파일 여러곳에 분산시키는 것 방지
  - 상대경로 이용위해 같은 파일 여러 폴더에 복제하는 경우 존재
    - 원본소스 관리 어려움 & 캐시에도 도움안됨
    - 캐시서버는 URL을 키값으로 동작해 복제된 URL만큼 복사본생성
  - 동일한 파일은 한 폴더에 관리, 관련 URL 참조

### 캐시 키 올바르게 사용하기

- 캐시 키: 캐시 서버가 원본 복사본 저장, 빠른 조회위해 사용하는 키값
  - 일반적으로 클라이언트가 요청하는 URL을 캐시 키로 이용
  - 일반적인 캐시 키 구성: `호스트/패스?쿼리 스트링`
    - `www.adad.com/kr/feo/myPic.jpg?width=100`
- 캐시 오염: 원본 서버에 하나의 원본파일, 캐시에 복사본 여러개 존재
  - 최종 사용자에게 영향 없으나 캐시서버 효율성에 영향
  - 캐시 오염 방지 방법
    1. URL에 붙은 특정 쿼리 스트링 값 달라도 응답 동일시 캐시 키에서 쿼리 스트링 무시하도록 설정
    - 캐시서버의 특정쿼리 스트링 무시 설정 기능 이용
    - ex) 서버 부하 분산위해 서버선택하는 쿼리 스트링
    2. 쿼리 스트링 순서 동일 정렬
    - 쿼리 스트링 순서 변화시 캐시가 다르게 인식
    - 오름차순, 내림차순,,, 동일하게 순서 정렬해 호츌
    3. Vary헤더 바르게 이용
    - Vary헤더: 서버의 응답이 상황에 따라 달라짐
    - `Cache-Control: private` 사용해 중간 캐시서버에 캐시않도록 함 || 브라우저 환경과 관계없이 항상 동일 페이지 응답시 Vary 미사용
- 캐시 충돌: 요청 URL이 하나, 브라우저 따라 서버에서 제공하는 응답달라 한 브라우저의 응답만 캐시, 다른 브라우저의 사용자에게 잘못된 응답
  - 동적 페이지 캐시시 주로 발생
  - 캐시 충돌 방지 방법
    - 기본적으로 동적페이지에 캐시 미적용
    - 홈페이지의 첫 HTML 캐시 안함: 로그인 전 홈페이지 캐시시 로그인되지 않는 문제
    - 동적페이지에 캐시 적용시 `Cache-Control: private`로 사용자 브라우저에만 캐시

### CDN 사용하기

- 사용자에게 가깝게 캐시
- 글로벌 사용자 대상으로 웹 사이트 운영시 CDN서비스 이용해 콘텐츠 사용자 가까이 캐시해 서비스
  - 해외 사용자가 국내 원본서버로 웹 서비스 받으려면 여러 ISP, 네트워크 홉 거쳐야함
  - 내트워크 경로가 비용 효율적 방법으로 만들어져 시간 지연 발생
- CDN 이용시 세계 여러 지역 데이터 센터에 리버스 프록시 캐시서버구축
  - 정적콘텐츠 저장
  - 콘텐츠 요청시 가장 가까운 캐시서버에서 콘텐츠 서비스되어 시간 지연없이 웹페이지 빠르게 로딩

## 4. 동적콘텐츠 캐시

> 캐시 효율화 기본원칙: 많은 콘텐츠를 오래, 사용자와 가깝게 캐시

- 동적콘텐츠 처리시간이 전체 응답시간의 많은 부분 차지
- 동적 콘텐츠 캐시시 사용자 체감 응답시간 단축, 서버 리소스 절약

### 웹 콘텐츠 특성따른 분류

- 정적 콘텐츠와 동적 콘텐츠
  - 정적 콘텐츠: 생성되어 거의 변하지 않는 콘텐츠
    - 이미지, 동영상,CSS, JS,,,
  - 동적 콘텐츠: 사용자 요청따라 서버가 바로 생성하는 콘텐츠, 변수에 따라 내용변화(사용자 정보, 시간,,,)
    - 장바구니, 주식시세,,, JSON,XML, 동적HTML형태로 전달
- 익명 콘텐츠와 개인화 콘텐츠
  - 익명 콘텐츠: 누구에게나 드러나는 콘텐츠
  - 개인화 콘텐츠: 요청한 사용자 정보따라 다르게 나타나는 콘텐츠
    - 개인프로필화면, 예약정보, 장바구니 정보,,, 개인별 맞춤정보
- 시간에 민감한 콘텐츠와 시간에 둔감한 콘텐츠
  - 시간 민감 여부: 콘텐츠 필요 사용자, 비즈니스 목적따라 다름
    - 시간 민감: 주식시세, 환율정보,,,
    - 시간에 덜 민감: 일기예보, 선박스케쥴,,,

### 동적 콘텐츠 캐시

- 원본서버가 사용자에게 동적콘텐츠 전달하는 방법 2가지
  1. 동적 정보를 쿠키에 넣어 보내는 방법
  - 요청 쿠키, 헤더나 쿼리 스트링의 동적콘텐츠에 대한 정보를 캐시키에 추가해 동적콘텐츠 캐시
  - 로그인 정보가 쿠키에 있는 경우 / 없는 경우 그룹화해 없을때만 캐시
  - 주의사항
    - 보안: 개인화 콘텐츠의 경우 사생활 침해 가능
    - 캐시서버용량: 개인화콘텐츠가 많아 캐시서버용량소진시 이전 객체 삭제위해 CPU사용량 증가해 캐시효율 감소, 크게 그룹화 가능한 콘텐츠에 국한해 이용 권장
  - 캐시키에 요청쿠키, 헤더나 쿼리 스트링 포함해 캐시 가능한 캐시서버 적음
  2. Ajax요청으로 관련정보를 동적으로 받아오는 방법
  - Ajax요청의 응답 형태인 JSON/XML 타입 콘텐츠는 다른 정적 응답 타입과 동일하게 캐시 가능
  - 시간 민감여부가 관건: 캐시하려는 콘텐츠 시간따른 민감도 결정, 캐시주기 설정해 만료시에만 갱신
  - 주의사항
    - 캐시가 통상 HTTP GET방식에서 동작해 Ajax요청대한 응답 캐시시 GET방식 이용
    - 캐시주기로 0TTL 사용시 서버에서 해당 콘텐츠대한 IMS(If-Modified-Since)요청 지원 필요: IMS요청 미지원시 요청마다 새로운 콘텐츠로 응답해 캐시 안하는 것과 동일

### POST 응답 캐시

- GET 메소드
  - 요청 URL에 붙이는 쿼리스트링 길이 제한, 요청 URL 노출
  - 서버에 GET 메소드 이용해 개인정보 전송 미적합
- POST 메소드: HTTP페이로드 메시지에 쿼리스트링 포함시켜 전송시 이용
  - 데이터 크기 제한 없음, 브라우저 통해 쉽게 확인 불가해 안전
  - POST 메서드 의한 응답은 POST 요청본문에 포함된 매개 변수의해 결정
  - 브라우저 캐시나 조회 이력에 남지않고 서버에 캐시안됨
  - 단, 입력 매개변수 동일 시 서버에서 항상 동일 응답 & 응답 내용이 보안 측면에서 공개시 안전 내용이면 POST응답 캐시 가능
    - 캐시오염, 캐시충돌 방지 위해 캐시키에 요청 매개변수값 모두 포함
    - 매개변수 값 노출안되도록 해시 알고리즘 이용해 암호화
- POST 요청 / 응답 캐시시 조건
  1. 매개 변숫값에 항상 같은 응답
  2. 개인 정보가 포함되지 않음
  3. 요청 사이즈가 크지 않음
  - HTTP페이로드와 달리 캐시키는 하나의 스트링으로 구성되므로 길이 제한 가능
  - 사용하는 캐시서버의 POST요청 캐시 대한 제약사항 사전에 확인필요

## 5. 고급 캐시 전략

- 캐시서버에서 제공하는 캐시기능 외 캐시 성능 향상시키는 부가기능

### Edge Side Include

- 첫 HTML 캐시하지 않음: 해당 HTML 구성 콘텐츠 중 동적인 부분 존재
  - 사용자 프로필 정보,,,
- ESI: 인터넷 에지에서 웹 페이지 조각을 동적으로 조합, 조립, 전달 다능하게 문법, 용도를 정의한 XML 기반 표준 마크업 언어
  - 메인 페이지와 사용자프로필 페이지 조합해 클라이언트에 제공
  - 사용하는 웹 캐시가 ESI 지원해야함
  - HTML 문서내에 프로그램 로직 구현
  - 태그
    - include: 현 페이지의 현 위치에 포함하려는 리소스 명시
      - <esi: include src="URI" alt="URI" onerror="continue">
    - choose, when, otherwise: 조건부 로직만들 때 이용
    - try, attempt, except: Try-catch와 유사하게 예외처리기능 제공
    - remove: 태그안의 내용을 최종 HTML에 보이지 않게 제거
  - 특징
    - 한 페이지안에 다른 페이지 포함
    - 각 페이지에 다른 캐시정책
    - HTTP헤더 정보를 변수로 참조
    - 조건문 통해 변수값따라 비즈니스 로직 적용
    - 예외발생시 예외처리
    - 문법단순
  - 사용 상황
    1. 동적인 부분 존재시 별도로 만들어 원 페이지에 동적 삽입
    - 동적페이지 존재해도 나머지 콘텐츠 캐시해 성능향상
    - Ajax에 비해 RTT한번 절약 가능
    - 단, 서버 주기적 호출불가해 주기적 업데이트 필요시 미적합, 동적 콘텐츠 생성 시간 길거나 응답없을시 성능저하나 단일실패지점 가능해 과도연산 페이지에 미적합
    2. 서로 다른 성격의 콘텐츠를 각각의 캐시정책을 사용해 캐시
    - 헤더, 푸터,,, 정적콘텐츠, 한달단위 업데이트되는 메인 콘텐츠,,,
    - 각 콘텐츠 다르게 캐시: 웹 캐시 설정에 캐시 주기 다르게 지정, 메인 HTML안에 ESI이용해 나머지 콘텐츠 적절히 조합
    3. 사용자 등급따라 콘텐츠 제한
    - 사용자 등급대한 쿠키 추가 & 쿠키따라 별도 페이지 가져오도록 작성
    - 보안 구체적 고려 필요: 사용자별 보안토큰 발급, 페이지 호출전 토큰 검증통해 인가되지 않은 사용자가 유료콘텐츠 사용 방지
    - choose, when,otherwise 태그 이용해 비즈니스로직 작성
    4. 웹 어플리케이션 협업시 유용
    5. 유지보수 간편

### HTML5로컬 스토리지

- HTML5: 다양한 기능을 API통해 사용가능, 웹 페이지 자체가 웹, 모바일 애플리케이션으로 구동
  - 주요기능
    - WeSemantic Tag: 많은 DIV이용해 부여한 Semantic을 표준Tag로 정의해 사용
    - Web Storage: API통해 세션스토리지, 로컬스토리지 IndexedDB사용가능, 오프라인 상태에서 웹페이지 로딩
    - Multimedia: 플러그인 없이 오디오, 비디오 재생
    - Graphics: 그래픽위한 툴박스 확대
    - Device Access: 기기의 마이크로폰, 카메라,,,에 네이티브앱처럼 접근 가능
    - Perfomance: Web Worker도입해 백그라운드 프로세싱기능, 멀티스레드 이용해 속도 향상
    - Connectivity: Web Socket통해 클라이언트-서버간 TCP통신
    - CSS3
  - HTML 5 웹 스토리지: 사용자 정보, 웹 리소스를 브라우저 로컬 저장소에 저장해 재사용 가능, 쿠키 대체
    - 세션스토리지: 세션 살아있을 때만 저장
    - 로컬스토리지: 영원히 저장
    - IndexedDB: 오브젝트 스토어로 광범위한 데이터 저장시 사용
    - 사용자 정보 저장
      - 데이터 한번 저장시 세션주기, 만료없이 불러 쓸수 있어 보안상 안전, 용량제한 5MB, Key/Value페어
      - <->쿠키: 네트워크 통해 전달해 보안 취약, 도메인당 4KB이내, 50개 초과 불가한 제약
    - 사용자 정보뿐만라니라 웹 사이트 중요 리소스 저장시에도 사용가능
      - API이용해 해당 리소스 스토리지에 존재 확인, 없을 경우 사이트에 동적로딩 시키며 리소스 다운시 URL 키값으로 스토리지에 저장
      - 로컬스토리지에 CSS, JS 저장시 재방문할 때 로딩속도 개선 가능
      - 폰트 파일 저장해 폰트의한 사이트 로딩 지연 방지
