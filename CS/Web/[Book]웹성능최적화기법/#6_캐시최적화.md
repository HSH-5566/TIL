# 캐시최적화

## 1. 캐시

- 캐시: 콘텐츠 요청에 빠르게 응답위해 서버-클라이언트 사이 응답 콘텐츠의 사본 저장하는 공간
  - 사용자의 같은 요청에 응답하는 리소스 동일시 이용
  - 서버-클라이언트 사이에 존재, 서버 성능향상시키는 역할
  - 웹의 경우 HTML, CSS, JS 등 정적 콘텐츠 많음
- 캐시 서버: 캐시를 유지, 처리하는 별도의 서버
  - 캐시서버의 종류
    - > 기능상 차이 있으나 캐시 컨트롤 기본 원리는 동일
    - 브라우저 캐시(로컬캐시)
      - 브라우저에 위치
      - 한번 다운한 리소스를 재사용해 사이트 로딩 빠르게 함
    - 프록시 캐시
      - 브라우저와 ISP에 위치
      - 조직내 사용자가 접속하는 웹 사이트 리소스 캐시해 네트워크 연결과 대역폭 사용률 감소, 사용자 웹 사이트로딩 빠르게 함
    - 트랜스패어런트 캐시
      - ISP에 위치
      - ISP에서 이를 사용해 ISP간 대역폭 낭비 방지
    - 리버스 프록시 캐시(웹 캐시)
      - ISP와 웹서버에 위치
      - 원본 서버로 향하는 트래픽 대역폭 감소&사용자 응답 개선
      - 서버에서 성능향상위해 별도로 사용
      - 웹 캐시: 리버스 프록시 서버(웹서버)에 캐시 기능 추가해 리버스 프록시 캐시서버로 이용
        - Apache HTTP Server: mod_cache, mod_cache_disk, mod_file_cache 모듈 활성화해 캐시서버로 활용 가능
        - Apache Traffic Server: 오픈소스 웹 캐시서버, 성능&확장성 뛰어난 웹 캐시 서버
        - Nginx: 웹 서버 중 하나로 콘텐츠 캐시 기능 제공
        - Varnish Cache: 캐시 통한 HTTP가속 목적으로 개발된 오픈소스 소프트웨어, 캐시 및 가속 기능 제공

## 2. 웹 캐시 동작 원리

- 웹 캐시
  - 웹 서버와 웹 브라우저의 중간에 위치, 최초 원본 콘텐츠 요청을 최종서버에 보내 응답받고 복사본 만들어 저장해 사용자에게 응답
  - 같은 콘텐츠 요청 시 복사본을 사용자에게 전달
  - > 원본서버로의 트래픽 줄이고 사용자 요청대한 반응속도 향상
  - 모든 웹 콘텐츠 캐시는 불가
    - 개인정보 보호
  - 콘텐츠 변경시 감지하여 원본서버에 요청
- 캐시서버: HTTP/1.1 규격을 기반으로 동작
- HTTP
  - 인터넷에서 데이터 주고받기 위한 클라이언트/서버 모델의 프로토콜
    - 클라이언트가 특정 URL 요청을 서버에 전달
    - 서버에서 요청 처리해 URL에 해당하는 응답 클라이언트에게 전달
    - 브라우저(클라이언트) / 웹서버(서버) / 프록시서버(클라이언트 / 서버)
  - OSI 7계층의 Application 레벨 프로토콜, TCP/IP위에서 동작
  - TCP Connection 맺어지면 HTTP는 어떤 종류의 데이터든 전송가능
  - > 특징
    - 클라이언트 서버 모델
    - 비연결성, 상태유지않는 프로토콜 (Connectionless, Stateless)
    - 클라이언트와 서버간 HTTP메세지 주고받으며 통신
    - HTTP 메세지 = 헤더 + 바디
    - TransportLayer프로토콜로 TCP사용, 일반적으로 80포트(SSL은 443포트)
  - HTTP메세지
    - 헤더: 메세지 전송 및 처리에 필요한 데이터 -메세지 전송할 호스트명, URL패스...
    - 페이로드: 서버가 실제 전송하려는 데이터
      - html, 이미지 ...
- HTTP의 캐시제어 방식

  - HTTP/1.1부터 명시적으로 캐시제어가능한 헤더 추가: Cache-Control
  - 캐시제어 목적
    - 원본서버로 요청하는 수 최소화: 네트워크왕복수 감소 = 응답속도단축
    - 완전한 콘텐츠 응답안해도 됨: 네트워크 대역폭, 리소스 낭비 감소, 비용 효율화
  - HTTP헤더

    - Expire: HTTP/1.0에서 원본서버 콘텐츠 유효기간 설정
      - 명시적 캐시제어않고 브라우저와 같은 캐시서버에서 콘텐츠 언제까지 저장할지 판단
      - 원본서버에서 Expire, Date헤더(요청대한 응답작성시점) 함께 전송
        - 원본서버 시간 기준으로 생성, HTTP Date형식
      - 응답의 캐시유지시간(TTL): Expire - Date
    - ETag: 원본서버가 리소스 식별위해 부여하는 고유번호
      - 캐시서버에서 원본서버의 리소스가 만료, 갱신해야하는지 판단
      - 따옴표내 임의의 문자조합: ETag: "2sad23 da2312d"
      - Strong ETag: 모든 리소스에 유일한 값, 생성 어렵
      - Weak ETag: 간단하게 생성, 신뢰도 감소, 원본서버에서 ETag역할 중요치 않을 시 w/를 붙여 캐시서버에 전달
        - w/: 해당 값이 유일하지 않을 수 있으나 괜찮다는 의미
    - Cache-Control
      - 캐시서버에서 Cache-Control헤더 사용한동작순서
        1. 첫 요청에 캐시된 응답없어 캐시서버가 원본서버에 그대로 요청전송
        2. 첫 요청 대해 원본서버에서 응답생성, 객체 언제까지 유효한지 HTTP헤더에 명시
        3. 캐시서버가 해당 요청대한 캐시키, 응답 저장 및 만료일 설정 후 요청자에게 응답 전송
        4. 같은 요청이 만료일 지나지 않았을 시 캐시에 저장된 응답 사용자에게 전송
        - > 사용자에 대한 응답시간 단축
      - max-age: HTTP/1.1애서 콘텐츠 캐시 유지시간 정의(유효기간)
        - 원본서버가 이를 이용해 캐시에서 특정 콘텐츠 얼마나 유지해야하는지 명시적으로 설정
        - 기간 지날시 캐시서버가 원본서버에 변경여부 체크 || 갱신
      - s-maxage: CDN과 같은 공용캐시주기 관리
        - 사용중인 모든 CDN캐시 주기 일괄적으로 설정, 변경 가능
        - CDN업체가 헤더 지원하는지 확인하고 이용
      - public: 해당 응답이 모든 캐시서버에 캐시가능, 사용자제한 없이 모든 사용자에게 응답 전달 가능
      - private: 요청한 사용자만 캐시가능, CDN같은 범용캐시서버에서 캐시시 응답을 모든 사용자에게 공유불가
        - 개인정보 보호가 아닌 응답메세지를 어디에 캐시할 것인지 지정
      - no-cache
        - 요청헤더
          - 브라우저가 원본서버나 캐시서버에게 캐시된 응답 받지않음
          - 캐시서버가 원본서버에서 최신의 응답을 받아 사용자에게 전달
          - <-> max-age=0: 캐시된 콘텐츠의 변경이 있는지 검증 후 유효하면 캐시에 있는 값 반환
        - 응답헤더
          - 원본 서버가 캐시서버에게 캐시된 응답 전송전 원본서버 확인하도록 강제
          - 매 요청마다 캐시된 복사본과 원본 서버와 검증 강제
          - max-age=0과 동일
          - 특정 헤더만 캐시않도록 설정: 지시자 옆에 캐시안하려는 헤더 나열, 해당 헤더를 제외한 응답을 캐시서버가 캐시
      - no-store: 서버가 로컬 저장소에 메세지 저장않도록 지시
        - 응답 메세지가 저장소에 저장되는 것 금지
        - 캐시 데이터의 예기치않은 유출방지: 개인정보보호수준 향상되나 완벽한 보안 매커니즘아님
        - <-> no-cache: 응답 항상 최신으로 유지하나 로컬 저장소에 저장방지 안함

    > Expire, Cache-Control: 원본 서버 콘텐츠의 캐시 TTL결정

    - HTTP/1.0기반의 캐시서버, 브라우저는 Cache-Control:max-age 미지원하므로 원본서버는 모든응답에 두 헤더 모두 표시
    - HTTP/1.1지원하는 캐시서버는 HTTP응답에 두헤더 모두 명시시 Cache-Control우선 사용

- 캐시 유효성 체크
  - 사용자가 콘텐츠를 캐시에 요청시 저장된 응답의 age > max-age면 응답 신뢰 불가
    - 캐시가 원본서버에 요청해 새응답(콘텐츠+max-age재설정)
  - 조건부요청
    - 캐시된 내용과 동일 응답 서버에서 전송시 서버자원, 네트워크 대역폭 낭비 -> 비효율적 요청/응답 방지하는 메커니즘
    - 저장된 응답 TTL만료시 TTL주기 동안 콘텐츠 변화했을때만 새 응답 생성하도록 요청
      - 웹 캐시에서 조건부요청을 서버에 전송
      - 변경 존재시 200응답코드 & 변경된 콘텐츠를 응답 본문에 포함해 전송
      - 변경 없을 시 304응답코드(Not-modified)만 헤더에 설정해 전송
        - 응답에 본문이 없어 서버, 네트워크 자원낭비 방지
  - 조건부요청 방법
    - 시간기반 조건부 요청
      - 요청대한 원본 서버의 콘텐츠가 캐시에 저장 후 콘텐츠 변경을 콘텐츠의 최종변경시간 중심으로 확인
      - 원본서버가 콘텐츠 응답 전송시 Last-Modified 헤더에 최종변경날짜, 시간 작성해 전송
      - 캐시가 최초 요청대한 응답 저장, TTL 시간지난 후 같은 요청시 원본서버에 '최종 변경시간 후 변경사항존재시 전체응답 재요청' & If-Modified-Since헤더에 Last-Modified값 복사해 원본서버에 전송
    - 콘텐츠기반 조건부 요청
      - 요청대한 원본 서버의 콘텐츠가 캐시에 저장된 후 변경됐는지 콘텐츠 고윳값 중심으로 확인
      - 교윳값: 해시값이용, ETag헤더
      - 캐시가 최초 요청대한 응답 저장, TTL 시간지난 후 같은 요청시 원본서버에 '해당 콘텐츠와 일치하는 고윳값없을 시 전체응답 재요청' & If-none-match헤더에 ETag값 복사해 원본서버에 전송
    - > 변경사항존재시: 200코드 & 본문이 존재하는 완전한 응답
    - > 변경사항없을시: 304코드만 있는 응답헤더만 전송
- 캐시 콘텐츠 갱신

  - 웹 사이트 개편 || 콘텐츠 급한 변경시 캐시 복사본 강제 갱신필요
  - 퍼지: 저장소를 완전히 지우는 방식

    - 캐시서버에서 캐시 모두 지우는 명령어, API 제공
    - 많은 캐시 퍼지시 원본서버에 자원 충분한지 확인: 캐시안된 요청이 한번에 원본 서버에 몰려 서버리소스 부담
      - 단계적으로 나누어 퍼지 || 무효화방안 이용
    - 프로모션, 새로운 페이지 오픈시: 테스트 툴 이용해 서비스할 웹 페이지 리소스 캐시에 미리 저장

  - 무효화: 조건부 요청을 통해 캐시된 리소스 중 변경있는 리소스만 새로 갱신
    - Cache-Control 이용: 캐시서버 내용 강제로 무효화
      - `Cache-Control: max-age=0, must-revalidate`
    - 원본서버, 웹 캐시서버에서 이용시 퍼지와 같이 새 콘텐츠 받으려는 트래픽 증가
      - 퍼지와 다르게 대부분 If-modified-since, if-none-match 요청, 변경된 리소스만 전체 콘텐츠 반환
      - 네트워크 대역폭낭비 감소
  - 비동기 캐시 갱신
    - 시용자가 기한 만료된 콘텐츠 요청전 미리 최신 콘텐츠 받아두는 방법
      - `Cache-Control: max-age=600, state-while-revalidate=30`
      - 600초간 캐시에 저장된 리소스 받고 이후 30초간은 만료되었으나 여전히 캐시된 리소스를 서비스 받음
      - 캐시는 그동안 서버와 통신해 새로운 콘텐츠 비동기적으로 받아옴
